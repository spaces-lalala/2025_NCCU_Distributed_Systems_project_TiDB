# FastAPI 後端修復報告

**日期**: 2025年5月30日  
**修復目標**: 解決 SQLAlchemy 表格重複定義、外鍵約束錯誤、422 錯誤問題和路由衝突問題  

## 問題概述

啟動 FastAPI 應用時遇到以下主要錯誤：
1. `Table 'products' is already defined for this MetaData instance` - 重複定義表格
2. `Referencing column 'product_id' and referenced column 'id' in foreign key constraint are incompatible` - 外鍵類型不匹配
3. `VARCHAR requires a length on dialect mysql` - MySQL VARCHAR 缺少長度定義
4. 模組導入錯誤：無法從 `api` 導入 `products`
5. **新增**: 422 (Unprocessable Entity) 錯誤 - 前後端字段名稱不匹配
6. **新增**: FastAPI 307 重定向問題導致授權頭丟失
7. **新增**: 訂單創建時語法錯誤和導入錯誤
8. **新增**: 路由衝突問題 - bestsellers API 被 {product_id} 路由攔截，返回 422 錯誤
9. **新增**: 前端歷史訂單顯示問題 - 字段名稱不匹配導致 `toFixed()` 錯誤
10. **新增**: 重複路由定義問題 - main.py 中存在與 api/product.py 重複的路由定義

## 修改檔案清單

### 1. models/__init__.py
**修改原因**: 解決重複的 Product 模型定義問題
```python
# 修改前
from .user import User
from .order import Order
from .order_item import OrderItem
from .product import Product  # 這裡導入了重複的 Product
from .item import Item

# 修改後
from .user import User
from .order import Order, Product, Category  # 統一從 order.py 導入
from .order_item import OrderItem
from .item import Item
```

### 2. models/product.py
**修改原因**: 移除重複的 Product 類別定義，改為重新匯出
```python
# 修改前
from sqlalchemy import Column, Integer, String, Float, Text
from database import Base

class Product(Base):
    __tablename__ = "products"
    id = Column(String(64), primary_key=True, index=True)
    # ... 其他欄位定義

# 修改後
# 重新匯出 Product 類別，避免重複定義
from .order import Product, Category

__all__ = ['Product', 'Category']
```

### 3. main.py
**修改原因**: 修正模組導入錯誤和函數實現問題
```python
# 修改前
from api import orders, payments, products  # 錯誤：沒有 products.py 檔案

# 修改後
from api import orders, payments, product   # 正確：使用 product.py

# 同時修改路由註冊
# 修改前
app.include_router(products.router)

# 修改後
app.include_router(product.router)
```

**修改 get_product_detail 函數**:
```python
# 修改前
def get_product_detail(product_id: int, db: Session = Depends(get_db)):
    search_id = f"1{product_id}"  # 錯誤的字串轉換
    product = db.query(Product).filter(Product.id == search_id).first()

# 修改後
def get_product_detail(product_id: int, db: Session = Depends(get_db)):
    product = db.query(Product).filter(Product.id == product_id).first()  # 直接使用整數
```

### 4. models/order_item.py
**修改原因**: 修正外鍵類型不匹配問題
```python
# 修改前
class OrderItem(Base):
    product_id = Column(String(64), ForeignKey("products.id"))  # String 類型

# 修改後
class OrderItem(Base):
    product_id = Column(Integer, ForeignKey("products.id"))     # Integer 類型，匹配 Product.id
```

### 5. schemas/order_item.py
**修改原因**: 統一 product_id 的資料類型和修正 Pydantic 配置
```python
# 修改前
class OrderItemBase(BaseModel):
    product_id: str  # 字串類型

class OrderItemOut(OrderItemBase):
    # ...
    class Config:
        orm_mode = True  # 舊版 Pydantic 語法

# 修改後
class OrderItemBase(BaseModel):
    product_id: int  # 整數類型，匹配資料庫

class OrderItemOut(OrderItemBase):
    # ...
    class Config:
        from_attributes = True  # 新版 Pydantic 語法
```

### 6. api/product.py
**修改原因**: 統一 product_id 參數類型
```python
# 修改前
@router.get("/{product_id}", response_model=ProductOut)
def get_product(product_id: str, db: Session = Depends(get_db)):  # 字串參數

# 修改後
@router.get("/{product_id}", response_model=ProductOut)
def get_product(product_id: int, db: Session = Depends(get_db)):  # 整數參數
```

### 7. schemas/product.py
**修改原因**: 統一產品 ID 類型和更新 Pydantic 配置
```python
# 修改前
class ProductBase(BaseModel):
    id: str  # 字串類型

class ProductOut(ProductBase):
    class Config:
        orm_mode = True          # 舊版語法
    class Config:               # 重複的 Config 定義
        orm_mode = True

# 修改後
class ProductBase(BaseModel):
    id: int  # 整數類型

class ProductOut(ProductBase):
    class Config:
        from_attributes = True   # 新版語法，單一定義
```

### 8. schemas/order.py
**修改原因**: 修正語法錯誤和更新 Pydantic 配置
```python
# 修改前
class OrderOut(OrderBase):
    items: List[OrderItemOut]    class Config:  # 缺少換行
        orm_mode = True

# 修改後
class OrderOut(OrderBase):
    items: List[OrderItemOut]
    
    class Config:
        from_attributes = True
```

### 9. models/item.py
**修改原因**: 修正 MySQL VARCHAR 長度問題
```python
# 修改前
class Item(Base):
    id = Column(String, primary_key=True, index=True)      # 缺少長度
    name = Column(String, index=True)                      # 缺少長度
    description = Column(String, nullable=True)            # 缺少長度

# 修改後
class Item(Base):
    id = Column(String(64), primary_key=True, index=True)  # 指定長度
    name = Column(String(255), index=True)                 # 指定長度    description = Column(String(1000), nullable=True)      # 指定長度
```

### 10. main.py (新增修復)
**修改原因**: 解決 FastAPI 重定向問題，防止授權頭丟失
```python
# 修改前
app = FastAPI(title="TiDB Shopping Backend")

# 修改後
app = FastAPI(title="TiDB Shopping Backend", redirect_slashes=False)
```

### 11. TiDB_shopping_frontend/src/views/CheckoutPage.vue (新增修復)
**修改原因**: 修正前端發送的字段名稱格式，統一使用 snake_case
```javascript
// 修改前
const orderItems = cartItems.value.map(item => ({
  productId: item.id,        // camelCase
  productName: item.name,
  quantity: item.quantity,
  price: item.price
}));

const orderPayload = {
  items: orderItems,
  totalAmount: totalAmount.value
};

// 修改後
const orderItems = cartItems.value.map(item => ({
  product_id: parseInt(item.id),  // snake_case 且轉為整數
  quantity: item.quantity
}));

const orderPayload = {
  items: orderItems
  // 移除 totalAmount，由後端計算
};
```

### 12. TiDB_shopping_frontend/src/types/order.ts (新增修復)
**修改原因**: 更新 TypeScript 接口以匹配後端 schema
```typescript
// 修改前
export interface OrderItemForCreation {
  productId: string;
  productName: string;
  quantity: number;
  price: number;
}

export interface OrderCreationPayload {
  items: OrderItemForCreation[];
  totalAmount: number;
}

// 修改後
export interface OrderItemForCreation {
  product_id: number;  // snake_case 且為數字類型
  quantity: number;
}

export interface OrderCreationPayload {
  items: OrderItemForCreation[];
  // 移除 totalAmount
}
```

### 13. api/orders.py (新增修復)
**修改原因**: 修正語法錯誤、導入錯誤和字段名稱匹配問題
```python
# 修改前
from schemas import OrderOut, OrderCreationRequest, OrderItemBase
from schemas.order import OrderOut
# 缺少 OrderItemOut 導入

def create_order(...):
    for item in order_data.items:
        # ...
        total_amount += item.price * item.quantity  # 錯誤：item 沒有 price 屬性
    
    # ...
    db.add(new_order)    # 建立訂單項目 & 扣庫存  # 語法錯誤：缺少換行
    
    for item in order_data.items:
        product = db.query(Product).filter(Product.id == item.productId).first()  # 錯誤字段名

# 修改後
from schemas import OrderOut, OrderCreationRequest, OrderItemBase
from schemas.order import OrderOut
from schemas.order_item import OrderItemOut  # 添加缺少的導入

def create_order(...):
    for item in order_data.items:
        product = db.query(Product).filter(Product.id == item.product_id).first()
        # ...
        total_amount += product.price * item.quantity  # 正確：使用從數據庫獲取的價格
    
    # ...
    db.add(new_order)
    
    # 建立訂單項目 & 扣庫存  # 正確的換行
    for item in order_data.items:
        product = db.query(Product).filter(Product.id == item.product_id).first()  # 正確字段名
```

### 14. main.py (路由衝突修復)
**修改原因**: 移除重複的產品路由定義，避免與 api/product.py 衝突
```python
// 修改前
app.include_router(product.router, prefix="/api/products", tags=["products"])

# 重複的路由定義
@app.get("/api/products/bestsellers")
def get_bestsellers_main(db: Session = Depends(get_db)):
    # 重複定義，與 api/product.py 中的路由衝突

# 修改後
app.include_router(product.router, prefix="/api/products", tags=["products"])
# 移除重複的路由定義，統一在 api/product.py 中管理
```

### 15. api/product.py (路由重新排序修復)
**修改原因**: 解決路由衝突問題，確保 bestsellers API 正常工作
```python
# 修改前 - 路由順序導致衝突
@router.get("/{product_id}", response_model=ProductDetailOut)
def get_product(product_id: int, db: Session = Depends(get_db)):
    # 這個路由會攔截 /bestsellers 請求

@router.get("/bestsellers", response_model=List[ProductOut])
def get_bestsellers(db: Session = Depends(get_db)):
    # 這個路由永遠不會被執行

# 修改後 - 正確的路由順序
@router.get("/bestsellers", response_model=List[ProductOut])
def get_bestsellers(db: Session = Depends(get_db)):
    products = db.query(Product).filter(Product.is_bestseller == True).all()
    return products

@router.get("/{product_id}", response_model=ProductDetailOut)
def get_product(product_id: int, db: Session = Depends(get_db)):
    product = db.query(Product).filter(Product.id == product_id).first()
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    return product
```

### 16. TiDB_shopping_frontend/src/views/MemberProfilePage.vue (顯示修復)
**修改原因**: 修正訂單歷史顯示中的字段名稱匹配問題
```javascript
// 修改前
const columns = [
  { prop: 'orderNumber', label: '訂單編號' },
  { prop: 'totalAmount', label: '總金額', formatter: (row) => `$${row.totalAmount.toFixed(2)}` }
];

// 修改後 - 使用正確的 snake_case 字段名稱
const columns = [
  { prop: 'order_number', label: '訂單編號' },
  { prop: 'total_amount', label: '總金額', formatter: (row) => `$${row.total_amount?.toFixed(2) || '0.00'}` }
];
```

### 17. TiDB_shopping_frontend/src/types/order.ts (類型更新)
**修改原因**: 更新 Order 和 OrderItem 接口以匹配後端響應格式
```typescript
// 修改前 - camelCase 格式
export interface Order {
  id: number;
  orderNumber: string;
  totalAmount: number;
  createdAt: string;
  items: OrderItem[];
}

export interface OrderItem {
  id: number;
  productId: number;
  productName: string;
  quantity: number;
  price: number;
}

// 修改後 - snake_case 格式匹配後端
export interface Order {
  id: number;
  order_number: string;
  total_amount: number;
  created_at: string;
  items: OrderItem[];
}

export interface OrderItem {
  id: number;
  product_id: number;
  product_name: string;
  quantity: number;
  price: number;
}
```

### 18. TiDB_shopping_frontend/src/views/CheckoutPage.vue (訂單確認修復)
**修改原因**: 修正訂單創建成功後的字段引用
```javascript
// 修改前
if (response.data.success) {
  ElMessage.success(`訂單創建成功！訂單號：${response.data.orderNumber}`);
  router.push(`/order-confirmation/${response.data.orderNumber}`);
}

// 修改後
if (response.data.success) {
  ElMessage.success(`訂單創建成功！訂單號：${response.data.order_number}`);
  router.push(`/order-confirmation/${response.data.order_number}`);
}
```

## 修改原因總結

### 1. 資料模型一致性
- **問題**: Product 模型在 `order.py` 和 `product.py` 中重複定義
- **解決方案**: 統一使用 `order.py` 中的定義，`product.py` 改為重新匯出

### 2. 外鍵類型一致性
- **問題**: `Product.id` 是 Integer，但 `OrderItem.product_id` 是 String
- **解決方案**: 統一所有相關欄位和參數為 Integer 類型

### 3. 資料庫相容性
- **問題**: MySQL 要求 VARCHAR 類型必須指定長度
- **解決方案**: 為所有 String 欄位添加適當的長度限制

### 4. 框架版本相容性
- **問題**: 使用了舊版 Pydantic 的 `orm_mode` 配置
- **解決方案**: 更新為新版的 `from_attributes` 配置

### 5. 模組導入正確性
- **問題**: 嘗試導入不存在的 `products` 模組
- **解決方案**: 修正為正確的 `product` 模組名稱

### 6. 前後端字段名稱一致性 (新增)
- **問題**: 前端使用 camelCase (`productId`)，後端期望 snake_case (`product_id`)
- **解決方案**: 統一前端發送格式為 snake_case，並確保數據類型匹配

### 7. HTTP 重定向問題 (新增)
- **問題**: FastAPI 默認會對末尾斜杠進行 307 重定向，導致 Authorization 頭丟失
- **解決方案**: 設置 `redirect_slashes=False` 避免重定向

### 8. 業務邏輯正確性 (新增)
- **問題**: 訂單總金額由前端計算，可能存在安全隱患和不一致性
- **解決方案**: 改為後端從數據庫獲取實際產品價格並計算總金額

### 9. 路由衝突問題 (新增)
- **問題**: `/api/products/bestsellers` 被 `/api/products/{product_id}` 路由攔截，返回 422 錯誤
- **解決方案**: 將具體路由 `/bestsellers` 放在參數路由 `/{product_id}` 之前
- **影響**: 確保 bestsellers API 能正確響應並返回暢銷商品列表

### 10. 前端顯示問題 (新增)
- **問題**: 訂單歷史頁面字段名稱不匹配，導致 `total_amount.toFixed()` 報錯
- **解決方案**: 更新前端組件使用正確的 snake_case 字段名稱，並添加安全檢查
- **影響**: 修復前端訂單歷史顯示錯誤，確保金額正確格式化

### 11. 重複路由定義問題 (新增)
- **問題**: main.py 中存在與 api/product.py 重複的產品路由定義
- **解決方案**: 移除 main.py 中的重複路由，統一在 api/product.py 中管理
- **影響**: 避免路由衝突和混淆，確保 API 結構清晰

## 修改結果

經過上述修改後，應用程式應該能夠：
1. ✅ 正確啟動 FastAPI 伺服器
2. ✅ 成功創建所有資料庫表格
3. ✅ 正確處理外鍵約束
4. ✅ 支援所有 API 端點
5. ✅ 維持資料類型的一致性
6. ✅ **新增**: 正確處理前後端字段名稱匹配
7. ✅ **新增**: 避免 HTTP 重定向導致的授權問題
8. ✅ **新增**: 正確創建訂單並計算總金額
9. ✅ **新增**: 解決路由衝突問題，確保 bestsellers API 正常工作
10. ✅ **新增**: 修正前端歷史訂單顯示問題，解決字段名稱不匹配
11. ✅ **新增**: 移除重複路由定義，統一 API 管理結構

## 關鍵修復亮點

### 1. 解決 422 錯誤的核心問題
- **根本原因**: 前端發送 `productId` (camelCase)，後端期望 `product_id` (snake_case)
- **解決方案**: 統一使用 snake_case 命名規範
- **影響**: 確保訂單創建 API 能正常工作

### 2. 安全性改進
- **問題**: 前端計算訂單總金額存在被篡改風險
- **改進**: 後端根據產品 ID 從數據庫獲取實際價格並計算
- **好處**: 提高數據完整性和安全性

### 3. 路由衝突解決 (新增重點)
- **問題**: `/api/products/bestsellers` 路由被 `/api/products/{product_id}` 攔截
- **根本原因**: FastAPI 路由匹配是按照定義順序進行的，參數路由 `{product_id}` 會匹配任何字符串
- **解決方案**: 將具體路由 `/bestsellers` 定義在參數路由 `/{product_id}` 之前
- **技術細節**: 同時移除了 main.py 中的重複路由定義，統一在 api/product.py 中管理
- **影響**: 修復了 bestsellers API 返回 422 錯誤的問題，現在正確返回 HTTP 200 和產品數據

### 4. 前端顯示問題修復 (新增重點)
- **問題**: 訂單歷史頁面出現 `Cannot read property 'toFixed' of undefined` 錯誤
- **根本原因**: 前端組件使用 camelCase (`totalAmount`) 但後端返回 snake_case (`total_amount`)
- **解決方案**: 
  - 更新所有前端 TypeScript 接口使用 snake_case 命名
  - 修改 Vue 組件中的字段引用
  - 添加安全檢查 (`total_amount?.toFixed(2) || '0.00'`)
- **影響**: 確保訂單歷史頁面正確顯示金額信息，消除前端錯誤

## 測試建議

### 1. 訂單創建流程測試
```bash
# 1. 啟動後端服務器
cd TiDB_shopping_backend
python main.py

# 2. 啟動前端服務器  
cd TiDB_shopping_frontend
npm run dev

# 3. 測試完整的購物流程
# - 瀏覽產品
# - 添加到購物車
# - 進行結帳
# - 驗證訂單創建成功
```

### 2. API 端點驗證
- **GET /api/products** - 獲取產品列表
- **GET /api/products/bestsellers** - 獲取暢銷產品列表 ✅ **(已修復路由衝突)**
- **GET /api/products/{product_id}** - 獲取產品詳情
- **POST /api/orders** - 創建訂單 (重點測試) ✅ **(已修復 422 錯誤)**
- **GET /api/orders** - 獲取用戶訂單
- **GET /api/orders/{order_id}** - 獲取訂單詳情

### 3. 前端頁面驗證 (新增)
- **產品列表頁面** - 確認產品正確顯示
- **產品詳情頁面** - 確認單個產品信息正確
- **購物車頁面** - 驗證商品添加和數量修改
- **結帳頁面** - 測試訂單創建流程 ✅ **(已修復字段匹配)**
- **會員資料頁面** - 檢查訂單歷史顯示 ✅ **(已修復 toFixed 錯誤)**
- **暢銷商品區塊** - 確認 bestsellers API 正常工作 ✅

## 後續建議

1. **測試驗證**: 建議進行完整的 API 測試，確保所有端點正常運作
2. **資料庫遷移**: 如果現有資料庫中有舊的資料結構，可能需要進行資料遷移
3. **程式碼審查**: 檢查其他可能存在類似問題的地方
4. **文件更新**: 更新 API 文件以反映正確的資料類型
5. **前端一致性檢查**: 確保其他前端組件也使用相同的字段命名規範
6. **錯誤處理完善**: 考慮添加更詳細的錯誤訊息和異常處理
7. **性能優化**: 考慮添加資料庫查詢優化和緩存機制

## 修改檔案完整清單

### 後端檔案 (TiDB_shopping_backend/)
- `models/__init__.py` - 修正重複導入
- `models/product.py` - 移除重複定義
- `models/order_item.py` - 修正外鍵類型
- `models/item.py` - 添加 VARCHAR 長度
- `schemas/order_item.py` - 統一資料類型
- `schemas/product.py` - 統一 ID 類型
- `schemas/order.py` - 修正語法錯誤
- `api/product.py` - **重大修復**: 路由衝突問題
- `api/orders.py` - **重大修復**: 語法錯誤、導入錯誤、字段匹配
- `main.py` - 修正導入和重定向設置

### 前端檔案 (TiDB_shopping_frontend/)
- `src/views/CheckoutPage.vue` - **重大修復**: 字段命名和數據格式
- `src/types/order.ts` - **重大修復**: 接口定義更新
- `src/views/MemberProfilePage.vue` - **重大修復**: 訂單歷史顯示問題修復
- `src/services/orderService.ts` - 確保服務層匹配

---
*此報告記錄了所有為解決 SQLAlchemy、FastAPI 相容性問題、前後端數據不匹配問題、路由衝突問題和前端顯示問題而進行的修改。重點解決了導致 422 錯誤的字段名稱不匹配問題、bestsellers API 路由衝突問題，以及前端訂單歷史顯示的 toFixed() 錯誤，確保了與 TiDB 數據庫的正確連接和完整的購物流程運行。*
